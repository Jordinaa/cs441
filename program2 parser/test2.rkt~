#lang racket

; Define token and AST node structures
(struct token (type value) #:transparent)
(struct ast-node (type value children) #:transparent)

; Scanner - converts input string to list of tokens
(define (tokenize input)
  (let ([tokens '()]
        [current-pos 0])
    
    (define (current-char)
      (if (< current-pos (string-length input))
          (string-ref input current-pos)
          #false))
    
    (define (advance)
      (set! current-pos (+ current-pos 1)))
    
    (define (skip-whitespace)
      (let ([char (current-char)])
        (when (and char (char-whitespace? char))
          (advance)
          (skip-whitespace))))
    
    (define (add-token type [value #f])
      (set! tokens (cons (token type (or value (string (current-char)))) tokens))
      (advance))
    
    (define (scan-number)
      (let loop ([num-str ""])
        (let ([char (current-char)])
          (cond
            [(and char (char-numeric? char))
             (advance)
             (loop (string-append num-str (string char)))]
            [else
             (set! tokens (cons (token 'number num-str) tokens))]))))
    
    (define (scan-identifier)
      (let loop ([id-str ""])
        (let ([char (current-char)])
          (cond
            [(and char (or (char-alphabetic? char) (char-numeric? char)))
             (advance)
             (loop (string-append id-str (string char)))]
            [else
             (let ([uppercase-str (string-upcase id-str)])
               (set! tokens 
                     (cons 
                      (if (member uppercase-str '("PRINT" "IF" "THEN" "END"))
                          (token 'keyword uppercase-str)
                          (token 'identifier id-str))
                      tokens)))]))))
    
    ; Main scanning loop
    (let scan-loop ()
      (let ([char (current-char)])
        (when char
          (cond
            [(char-whitespace? char) 
             (advance)
             (scan-loop)]
            [(char-numeric? char)
             (scan-number)
             (scan-loop)]
            [(char-alphabetic? char)
             (scan-identifier)
             (scan-loop)]
            [(char=? char #\+) (add-token 'plus) (scan-loop)]
            [(char=? char #\-) (add-token 'minus) (scan-loop)]
            [(char=? char #\*) (add-token 'multiply) (scan-loop)]
            [(char=? char #\/) (add-token 'divide) (scan-loop)]
            [(char=? char #\() (add-token 'lparen) (scan-loop)]
            [(char=? char #\)) (add-token 'rparen) (scan-loop)]
            [(char=? char #\=) (add-token 'equals) (scan-loop)]
            [else (error (format "Unexpected character: ~a" char))]))))
    
    (reverse tokens)))

; Parser - converts tokens to AST
(define (parse tokens)
  (let ([current 0])
    
    (define (peek)
      (if (< current (length tokens))
          (list-ref tokens current)
          #f))
    
    (define (advance)
      (set! current (+ current 1))
      (list-ref tokens (- current 1)))
    
    (define (match? . types)
      (let ([token (peek)])
        (and token
             (member (token-type token) types))))
    
    ; Grammar rules
    (define (expression)
      (term))
    
    (define (term)
      (let loop ([left (factor)])
        (cond
          [(match? 'plus 'minus)
           (let* ([operator (token-value (advance))]
                  [right (factor)])
             (loop (ast-node 'binary operator (list left right))))]
          [else left])))
    
    (define (factor)
      (let loop ([left (primary)])
        (cond
          [(match? 'multiply 'divide)
           (let* ([operator (token-value (advance))]
                  [right (primary)])
             (loop (ast-node 'binary operator (list left right))))]
          [else left])))
    
    (define (primary)
      (cond
        [(match? 'number)
         (let ([token (advance)])
           (ast-node 'literal (token-value token) '()))]
        [(match? 'identifier)
         (let ([token (advance)])
           (ast-node 'variable (token-value token) '()))]
        [(match? 'lparen)
         (advance)
         (let ([expr (expression)])
           (if (match? 'rparen)
               (begin
                 (advance)
                 expr)
               (error "Expected ')'")))]))
    
    ; Start parsing
    (expression)))

; Pretty printer for AST
(define (print-ast node [indent ""])
  (printf "~a~a: ~a\n" 
          indent
          (ast-node-type node)
          (ast-node-value node))
  (for-each
   (lambda (child)
     (print-ast child (string-append indent "  ")))
   (ast-node-children node)))

; Test the parser
(define (test-parser input)
  (printf "Input: ~a\n" input)
  (let* ([tokens (tokenize input)]
         [ast (parse tokens)])
    (printf "\nTokens:\n")
    (for-each
     (lambda (tok)
       (printf "~a: ~a\n" (token-type tok) (token-value tok)))
     tokens)
    (printf "\nAST:\n")
    (print-ast ast)))

; Example usage
(module+ main
  (test-parser "3 + 4 * 2"))